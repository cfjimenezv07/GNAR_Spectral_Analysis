# Visualize Network with igraph
# ========================================
library(igraph)
igraph_net <- graph_from_adjacency_matrix(adj_mat_undir, mode = "undirected", diag = FALSE)
V(igraph_net)$label <- stationary_bank_codes
V(igraph_net)$name <- stationary_bank_codes
# Function to color nodes by region
get_label_color <- function(code) {
if (grepl("\\.us$|\\.ca$|\\.br$", code)) return("red")        # Americas
if (grepl("\\.es$|\\.fr$|\\.it$|\\.ch$|\\.gb$|\\.se$|\\.be$|\\.dk$|\\.no$", code)) return("darkblue")  # Europe
if (grepl("\\.tr$|\\.in$|\\.kr$|\\.cn$|\\.jp$", code)) return("darkgreen") # Asia
if (grepl("\\.au$", code)) return("darkviolet")               # Australia
return("gray")
}
V(igraph_net)$color <- "black"
V(igraph_net)$label.color <- sapply(V(igraph_net)$name, get_label_color)
set.seed(42)
layout_net <- layout_with_fr(igraph_net)
# Plot network
pdf(file = paste0(dir.p, "Network.pdf"), width = 12, height = 10)
plot(igraph_net,
layout = layout_net,
vertex.size = 4,
vertex.shape = "circle",
vertex.label.cex = 0.7,
vertex.label.family = "sans")
legend("topright",
legend = c("Americas", "Europe", "Asia", "Australia"),
text.col = c("red", "darkblue", "darkgreen", "darkviolet"),
pch = NA, bty = "n", cex = 0.9)
dev.off()
plot(igraph_net,
layout = layout_net,
vertex.size = 4,
vertex.shape = "circle",
vertex.label.cex = 0.7,
vertex.label.family = "sans")
# === Percentile-Based Threshold Selection ===
# For threshold selection. Please run Threshold_selecting.R
threshold <- 0.02
cat("Threshold set:", round(threshold, 4), "\n")
# ========================================
# Build Undirected Adjacency Matrix
# ========================================
adj_mat_undir <- matrix(0, K, K, dimnames = list(stationary_bank_codes, stationary_bank_codes))
for (i in 1:K) {
for (j in 1:K) {
if (i != j && (fevd[i, j] >= threshold || fevd[j, i] >= threshold)) {
adj_mat_undir[i, j] <- 1
adj_mat_undir[j, i] <- 1
}
}
}
diag(adj_mat_undir) <- 0
# ========================================
# Build Symmetric Weight Matrix
# ========================================
weight_mat <- matrix(0, K, K, dimnames = list(stationary_bank_codes, stationary_bank_codes))
for (i in 1:K) {
for (j in 1:K) {
if (i != j && adj_mat_undir[i, j] == 1) {
avg_val <- mean(c(fevd[i, j], fevd[j, i]))
weight_mat[i, j] <- avg_val
weight_mat[j, i] <- avg_val
}
}
}
diag(weight_mat) <- 0
cat("Network density:", mean(adj_mat_undir), "\n")
igraph_net <- graph_from_adjacency_matrix(adj_mat_undir, mode = "undirected", diag = FALSE)
V(igraph_net)$label <- stationary_bank_codes
V(igraph_net)$name <- stationary_bank_codes
# Function to color nodes by region
get_label_color <- function(code) {
if (grepl("\\.us$|\\.ca$|\\.br$", code)) return("red")        # Americas
if (grepl("\\.es$|\\.fr$|\\.it$|\\.ch$|\\.gb$|\\.se$|\\.be$|\\.dk$|\\.no$", code)) return("darkblue")  # Europe
if (grepl("\\.tr$|\\.in$|\\.kr$|\\.cn$|\\.jp$", code)) return("darkgreen") # Asia
if (grepl("\\.au$", code)) return("darkviolet")               # Australia
return("gray")
}
V(igraph_net)$color <- "black"
V(igraph_net)$label.color <- sapply(V(igraph_net)$name, get_label_color)
set.seed(42)
layout_net <- layout_with_fr(igraph_net)
plot(igraph_net,
layout = layout_net,
vertex.size = 4,
vertex.shape = "circle",
vertex.label.cex = 0.7,
vertex.label.family = "sans")
threshold <- 0.03
cat("Threshold set:", round(threshold, 4), "\n")
# ========================================
# Build Undirected Adjacency Matrix
# ========================================
adj_mat_undir <- matrix(0, K, K, dimnames = list(stationary_bank_codes, stationary_bank_codes))
for (i in 1:K) {
for (j in 1:K) {
if (i != j && (fevd[i, j] >= threshold || fevd[j, i] >= threshold)) {
adj_mat_undir[i, j] <- 1
adj_mat_undir[j, i] <- 1
}
}
}
diag(adj_mat_undir) <- 0
# ========================================
# Build Symmetric Weight Matrix
# ========================================
weight_mat <- matrix(0, K, K, dimnames = list(stationary_bank_codes, stationary_bank_codes))
for (i in 1:K) {
for (j in 1:K) {
if (i != j && adj_mat_undir[i, j] == 1) {
avg_val <- mean(c(fevd[i, j], fevd[j, i]))
weight_mat[i, j] <- avg_val
weight_mat[j, i] <- avg_val
}
}
}
diag(weight_mat) <- 0
cat("Network density:", mean(adj_mat_undir), "\n")
# ========================================
# Visualize Network with igraph
# ========================================
library(igraph)
igraph_net <- graph_from_adjacency_matrix(adj_mat_undir, mode = "undirected", diag = FALSE)
V(igraph_net)$label <- stationary_bank_codes
V(igraph_net)$name <- stationary_bank_codes
# Function to color nodes by region
get_label_color <- function(code) {
if (grepl("\\.us$|\\.ca$|\\.br$", code)) return("red")        # Americas
if (grepl("\\.es$|\\.fr$|\\.it$|\\.ch$|\\.gb$|\\.se$|\\.be$|\\.dk$|\\.no$", code)) return("darkblue")  # Europe
if (grepl("\\.tr$|\\.in$|\\.kr$|\\.cn$|\\.jp$", code)) return("darkgreen") # Asia
if (grepl("\\.au$", code)) return("darkviolet")               # Australia
return("gray")
}
V(igraph_net)$color <- "black"
V(igraph_net)$label.color <- sapply(V(igraph_net)$name, get_label_color)
set.seed(42)
layout_net <- layout_with_fr(igraph_net)
plot(igraph_net,
layout = layout_net,
vertex.size = 4,
vertex.shape = "circle",
vertex.label.cex = 0.7,
vertex.label.family = "sans")
# === Percentile-Based Threshold Selection ===
# For threshold selection. Please run Threshold_selecting.R
threshold <- 0.0121
cat("Threshold set:", round(threshold, 4), "\n")
# ========================================
# Build Undirected Adjacency Matrix
# ========================================
adj_mat_undir <- matrix(0, K, K, dimnames = list(stationary_bank_codes, stationary_bank_codes))
for (i in 1:K) {
for (j in 1:K) {
if (i != j && (fevd[i, j] >= threshold || fevd[j, i] >= threshold)) {
adj_mat_undir[i, j] <- 1
adj_mat_undir[j, i] <- 1
}
}
}
diag(adj_mat_undir) <- 0
# ========================================
# Build Symmetric Weight Matrix
# ========================================
weight_mat <- matrix(0, K, K, dimnames = list(stationary_bank_codes, stationary_bank_codes))
for (i in 1:K) {
for (j in 1:K) {
if (i != j && adj_mat_undir[i, j] == 1) {
avg_val <- mean(c(fevd[i, j], fevd[j, i]))
weight_mat[i, j] <- avg_val
weight_mat[j, i] <- avg_val
}
}
}
diag(weight_mat) <- 0
cat("Network density:", mean(adj_mat_undir), "\n")
plot(igraph_net,
layout = layout_net,
vertex.size = 4,
vertex.shape = "circle",
vertex.label.cex = 0.7,
vertex.label.family = "sans")
# ========================================
# Visualize Network with igraph
# ========================================
library(igraph)
igraph_net <- graph_from_adjacency_matrix(adj_mat_undir, mode = "undirected", diag = FALSE)
V(igraph_net)$label <- stationary_bank_codes
V(igraph_net)$name <- stationary_bank_codes
# Function to color nodes by region
get_label_color <- function(code) {
if (grepl("\\.us$|\\.ca$|\\.br$", code)) return("red")        # Americas
if (grepl("\\.es$|\\.fr$|\\.it$|\\.ch$|\\.gb$|\\.se$|\\.be$|\\.dk$|\\.no$", code)) return("darkblue")  # Europe
if (grepl("\\.tr$|\\.in$|\\.kr$|\\.cn$|\\.jp$", code)) return("darkgreen") # Asia
if (grepl("\\.au$", code)) return("darkviolet")               # Australia
return("gray")
}
V(igraph_net)$color <- "black"
V(igraph_net)$label.color <- sapply(V(igraph_net)$name, get_label_color)
set.seed(42)
layout_net <- layout_with_fr(igraph_net)
plot(igraph_net,
layout = layout_net,
vertex.size = 4,
vertex.shape = "circle",
vertex.label.cex = 0.7,
vertex.label.family = "sans")
# ========================================
# Compute shortest paths / hops
# ========================================
hop_mat <- distances(igraph_net)
diag(hop_mat) <- NA
hop_df <- melt(hop_mat)
colnames(hop_df) <- c("From", "To", "Hops")
all_nodes <- sort(unique(c(hop_df$From, hop_df$To)))
hop_df$From <- factor(hop_df$From, levels = all_nodes)
hop_df$To <- factor(hop_df$To, levels = all_nodes)
hop_df <- hop_df[hop_df$Hops <= 5, ]
hop_df$Hops_factor <- cut(hop_df$Hops,
breaks = c(-Inf, 1, 2, 3, 4, 5),
labels = c("1 hop", "2 hops", "3 hops", "4 hops", "5 hops"),
right = TRUE)
hop_df <- na.omit(hop_df)
custom_colors <- c("1 hop" = "#00008B", "2 hops" = "#006400", "3 hops" = "#FF0000",
"4 hops" = "darkviolet", "5 hops" = "darkorange")
hop_heatmap <- ggplot(hop_df, aes(x = To, y = From, fill = Hops_factor)) +
geom_tile(color = "lightgray") +
scale_fill_manual(values = custom_colors, name = "Hops", drop = FALSE) +
theme_minimal() +
labs(title = "Number of Hops Between Nodes", x = "To", y = "From") +
theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust = 1),
axis.text = element_text(size = 6),
panel.grid = element_blank())
print(hop_heatmap)
# ========================================
# GNAR Spectral Analysis
# ========================================
source("Aux_GNAR_spec.R")
gnar_net <- as.GNARnet(igraph_net)
# Plot corbit
pdf(file = paste0(dir.p, "corbit.pdf"), width = 12, height = 10)
corbit_plot_cpp(vts = data, net = gnar_net, max_lag = 20, max_stage = 5, partial = "yes")
# GNAR parametric estimation
# Model order selected from Corbit-plot above
alphaOrder <- 2
betaOrder <- c(1,1)
globalalpha <- TRUE
gnar_spec_param <- GNARSpec(vts = data,
net = gnar_net,
alphaOrder = alphaOrder,
betaOrder = betaOrder,
globalalpha = globalalpha,
W = weight_mat)
# ========================================
# GNAR Spectral Analysis
# ========================================
source("Aux_GNAR_spec.R")
gnar_spec_param <- GNARSpec_GBNC(vts = data,
net = gnar_net,
alphaOrder = alphaOrder,
betaOrder = betaOrder,
globalalpha = globalalpha,
W = weight_mat)
# ========================================
# GNAR Spectral Analysis
# ========================================
source("Aux_GNAR_spec.R")
gnar_spec_param <- GNARSpec_GBNC(vts = data,
net = gnar_net,
alphaOrder = alphaOrder,
betaOrder = betaOrder,
globalalpha = globalalpha,
W = weight_mat)
# ========================================
# GNAR Spectral Analysis
# ========================================
source("Aux_GNAR_spec.R")
gnar_spec_param <- GNARSpec_GBNC(vts = data,
net = gnar_net,
alphaOrder = alphaOrder,
betaOrder = betaOrder,
globalalpha = globalalpha,
W = weight_mat)
library(rlist)
# ========================================
# GNAR Spectral Analysis
# ========================================
source("Aux_GNAR_spec.R")
gnar_spec_param <- GNARSpec_GBNC(vts = data,
net = gnar_net,
alphaOrder = alphaOrder,
betaOrder = betaOrder,
globalalpha = globalalpha,
W = weight_mat)
# Functions for coherence / partial coherence
get_country <- function(code) sub(".*\\.", "", code)
compute_coherence <- function(spec_array, i, j) {
S_ii <- spec_array[i, i, ]
S_jj <- spec_array[j, j, ]
S_ij <- spec_array[i, j, ]
Mod(S_ij)^2 / (Mod(S_ii) * Mod(S_jj))
}
compute_partial_coherence <- function(spec_array, i, j) {
n_freq <- dim(spec_array)[3]
pcoh <- numeric(n_freq)
for (k in 1:n_freq) {
S <- spec_array[,,k]
G <- solve(S)
D_inv <- sqrt(abs(Re(diag(G))))
if (any(D_inv == 0)) { pcoh[k] <- NA; next }
D <- diag(1 / D_inv)
Gamma <- -D %*% G %*% D
pcoh[k] <- Mod(Gamma[i, j])^2
}
pcoh
}
# ==============================
# === 0. Setup and Inputs ===
# ==============================
countries <- sapply(stationary_bank_codes, get_country)
n_nodes <- length(stationary_bank_codes)
n_freq <- dim(gnar_spec_param)[3]
freqs <- seq(0, 0.5, length.out = n_freq)
group_palette <- c(
"Same Country - Connected" = "#B2182B",
"Diff Country - Connected" = "#2166AC",
"Disconnected"             = "#4D4D4D"
)
line_types <- c(1, 2, 3)  # Recycled across groups
# ==============================
# === 1. Function to Find Pairs ===
# ==============================
find_pair <- function(c1, c2, connected = TRUE) {
idx1 <- which(countries == c1)
idx2 <- which(countries == c2)
for (i in idx1) {
for (j in idx2) {
if (i != j && ((connected && adj_matrix[i,j] == 1) || (!connected && adj_matrix[i,j] == 0))) {
return(c(i, j))
}
}
}
return(NULL)
}
make_pairs_df <- function(pairs_list, group_name) {
df <- do.call(rbind, lapply(pairs_list, function(p) data.frame(t(find_pair(p[1], p[2], ifelse(length(p) == 3, p[3], TRUE))))))
df$group <- group_name
colnames(df) <- c("i", "j", "group")
return(df)
}
# ==============================
# === 2. Define Pairs ===
# ==============================
same_country_connected <- make_pairs_df(
list(c("us","us"), c("fr","fr"), c("jp","jp")),
"Same Country - Connected"
)
# ==============================
# === 2. Define Pairs ===
# ==============================
same_country_connected <- make_pairs_df(
list(c("us","us"), c("fr","fr"), c("jp","jp")),
"Same Country - Connected"
)
# ==============================
# === 1. Function to Find Pairs ===
# ==============================
adj_matrix =as.matrix(gnar_net)
adj_matrix
find_pair <- function(c1, c2, connected = TRUE) {
idx1 <- which(countries == c1)
idx2 <- which(countries == c2)
for (i in idx1) {
for (j in idx2) {
if (i != j && ((connected && adj_matrix[i,j] == 1) || (!connected && adj_matrix[i,j] == 0))) {
return(c(i, j))
}
}
}
return(NULL)
}
make_pairs_df <- function(pairs_list, group_name) {
df <- do.call(rbind, lapply(pairs_list, function(p) data.frame(t(find_pair(p[1], p[2], ifelse(length(p) == 3, p[3], TRUE))))))
df$group <- group_name
colnames(df) <- c("i", "j", "group")
return(df)
}
# ==============================
# === 2. Define Pairs ===
# ==============================
same_country_connected <- make_pairs_df(
list(c("us","us"), c("fr","fr"), c("jp","jp")),
"Same Country - Connected"
)
diff_country_connected <- make_pairs_df(
list(c("us","gb"), c("fr","es"), c("jp","kr")),
"Diff Country - Connected"
)
disconnected_pairs <- make_pairs_df(
list(c("it","jp", FALSE), c("fr","cn", FALSE), c("cn","jp", FALSE)),
"Disconnected"
)
disconnected_pairs <- make_pairs_df(
list(c("it","jp", FALSE), c("fr","cn", FALSE), c("cn","jp", FALSE)),
"Disconnected"
)
# ==============================
# === 2. Define Pairs ===
# ==============================
countries <- sapply(stationary_bank_codes, get_country)
n_nodes <- length(stationary_bank_codes)
n_freq <- dim(gnar_spec_param)[3]
freqs <- seq(0, 0.5, length.out = n_freq)
# === 1. Explicit Pair Selection ===
find_pair <- function(c1, c2, connected = TRUE) {
idx1 <- which(countries == c1)
idx2 <- which(countries == c2)
for (i in idx1) {
for (j in idx2) {
if (i != j && (connected && adj_matrix[i,j] == 1 || !connected && adj_matrix[i,j] == 0)) {
return(c(i, j))
}
}
}
return(NULL)
}
same_country_connected <- rbind(
data.frame(t(find_pair("us", "us")), group = "Same Country - Connected"),
data.frame(t(find_pair("fr", "fr")), group = "Same Country - Connected"),
data.frame(t(find_pair("jp", "jp")), group = "Same Country - Connected")
)
diff_country_connected <- rbind(
data.frame(t(find_pair("us", "gb")), group = "Diff Country - Connected"),
data.frame(t(find_pair("fr", "es")), group = "Diff Country - Connected"),
data.frame(t(find_pair("jp", "kr")), group = "Diff Country - Connected")
)
disconnected_pairs <- rbind(
data.frame(t(find_pair("it", "jp", connected = FALSE)), group = "Disconnected"),
data.frame(t(find_pair("fr", "cn", connected = FALSE)), group = "Disconnected"),
data.frame(t(find_pair("cn", "jp", connected = FALSE)), group = "Disconnected")
)
colnames(same_country_connected) <- colnames(diff_country_connected) <- colnames(disconnected_pairs) <- c("i", "j", "group")
# ==============================
# === 3. Assign Colors & Line Types ===
# ==============================
all_pairs$Color <- group_palette[all_pairs$group]
# ==============================
# === 3. Assign Colors & Line Types ===
# ==============================
all_pairs <- rbind(same_country_connected, diff_country_connected, disconnected_pairs)
all_pairs$i <- as.integer(all_pairs$i)
all_pairs$j <- as.integer(all_pairs$j)
all_pairs$pair_label <- paste0(stationary_bank_codes[all_pairs$i], "_", stationary_bank_codes[all_pairs$j])
group_palette <- list(
"Same Country - Connected" = "#B2182B",   # Dark Red
"Diff Country - Connected" = "#2166AC",   # Dark Blue
"Disconnected"             = "#4D4D4D"    # Dark Gray
)
line_types <- c(1, 2, 3)
all_pairs$Color <- NA
all_pairs$Lty <- NA
# ==============================
# === 4. Compute Spectral Quantities ===
# ==============================
make_spectral_df <- function(all_pairs, compute_fun) {
df <- do.call(rbind, lapply(1:nrow(all_pairs), function(row) {
i <- all_pairs$i[row]
j <- all_pairs$j[row]
data.frame(
Frequency = freqs,
Value = compute_fun(i, j),
Pair = all_pairs$pair_label[row],
Group = all_pairs$group[row],
Color = all_pairs$Color[row],
Lty = all_pairs$Lty[row]
)
}))
return(df)
}
mod_df   <- make_spectral_df(all_pairs, function(i,j) Mod(gnar_spec_param[i,j,]))
phase_df <- make_spectral_df(all_pairs, function(i,j) Arg(gnar_spec_param[i,j,]))
pcoh_df  <- make_spectral_df(all_pairs, compute_partial_coherence)
coh_df   <- make_spectral_df(all_pairs, compute_coherence)
# ==============================
# === 4. Compute Spectral Quantities ===
# ==============================
mod_df <- data.frame()
phase_df <- data.frame()
pcoh_df <- data.frame()
coh_df <- data.frame()
for (row in 1:nrow(all_pairs)) {
i <- all_pairs$i[row]
j <- all_pairs$j[row]
pair_label <- all_pairs$pair_label[row]
group <- all_pairs$group[row]
col <- all_pairs$Color[row]
lty <- all_pairs$Lty[row]
spec_ij <- gnar_spec_param[i, j, ]
mod_vals <- Mod(spec_ij)
phase_vals <- Arg(spec_ij)
pcoh_vals <- compute_partial_coherence(gnar_spec_param, i, j)
coh_vals <- compute_coherence(gnar_spec_param, i, j)
mod_df <- rbind(mod_df, data.frame(Frequency = freqs, Value = mod_vals,
Pair = pair_label, Group = group, Color = col, Lty = lty))
phase_df <- rbind(phase_df, data.frame(Frequency = freqs, Value = phase_vals,
Pair = pair_label, Group = group, Color = col, Lty = lty))
pcoh_df <- rbind(pcoh_df, data.frame(Frequency = freqs, Value = pcoh_vals,
Pair = pair_label, Group = group, Color = col, Lty = lty))
coh_df <- rbind(coh_df, data.frame(Frequency = freqs, Value = coh_vals,
Pair = pair_label, Group = group, Color = col, Lty = lty))
}
